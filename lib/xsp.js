// Generated by CoffeeScript 1.6.2
(function() {
  var app, async, cfgmore, cfgupdate, client, controller, controllers, cwd, dictionaries, express, fce, fs, http, https, inits, key, locals, model, name, path, pathsTo, report, route, routed, socketClient, socketController, tasks, value, xsp, yaml, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  express = require('express');

  fs = require('fs');

  async = require('async');

  yaml = require('js-yaml');

  report = require('./report');

  tasks = require('./tasks');

  http = require('http');

  https = require('https');

  path = require('path');

  xsp = module.exports;

  xsp.tasks = tasks;

  global.trace = console.log.bind(console);

  global.inspect = console.dir.bind(console);

  require('./colors.js').call(xsp);

  xsp.env = process.env.NODE_ENV || 'development';

  if (fs.existsSync("" + __dirname + "/../../../app/config/server.yml")) {
    xsp.cfg = require("" + __dirname + "/../../../app/config/server.yml").server;
  } else {
    xsp.cfg = {};
  }

  xsp.db = null;

  if (xsp.env === 'test') {
    global.xsp = xsp;
  }

  if (fs.existsSync("" + __dirname + "/../../../app/config/server." + xsp.env + ".yml")) {
    cfgmore = require("" + __dirname + "/../../../app/config/server." + xsp.env + ".yml").server;
    cfgupdate = function(tar, src) {
      var name, value, _results;

      _results = [];
      for (name in src) {
        value = src[name];
        if (tar[name]) {
          if (typeof tar[name] === 'object' && typeof src[name] === 'object') {
            if (!(tar[name] instanceof Array)) {
              _results.push(cfgupdate(tar[name], src[name]));
            } else {
              _results.push(tar[name] = src[name]);
            }
          } else {
            _results.push(tar[name] = src[name]);
          }
        } else {
          _results.push(tar[name] = src[name]);
        }
      }
      return _results;
    };
    cfgupdate(xsp.cfg, cfgmore);
  }

  xsp.languageDefaults = function(req) {
    var lang, _i, _len, _ref;

    if (!xsp.cfg.defaults) {
      return null;
    }
    _ref = req.acceptedLanguages;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      lang = _ref[_i];
      lang = lang.toLowerCase();
      if (xsp.cfg.defaults[lang]) {
        return xsp.cfg.defaults[lang];
      }
    }
    return xsp.cfg.defaults['*'];
  };

  cwd = process.cwd();

  xsp.require = function(module, workdir) {
    var ex, out, pwd, _ref, _ref1;

    if (workdir) {
      pwd = cwd;
      cwd = workdir;
      if (require.cache[require.resolve(module)]) {
        return require.cache[require.resolve(module)];
      }
      try {
        out = (_ref = require(module)) != null ? _ref.call(xsp) : void 0;
      } catch (_error) {
        ex = _error;
        trace.red("[xsp] failed to load module: " + module);
        console.error(ex);
      }
      cwd = pwd;
      return out;
    } else {
      if (require.cache[require.resolve("" + cwd + "/" + module)]) {
        return require.cache[require.resolve("" + cwd + "/" + module)];
      }
      try {
        return (_ref1 = require("" + cwd + "/" + module)) != null ? _ref1.call(xsp) : void 0;
      } catch (_error) {
        ex = _error;
        trace.red("[xsp] failed to load module: " + cwd + "/" + module);
        return console.error(ex);
      }
    }
  };

  xsp.autoload = function(dir, scope) {
    var ex, _ref;

    if (fs.existsSync("" + dir)) {
      if (fs.lstatSync(dir).isDirectory()) {
        return fs.readdirSync(dir).forEach(function(file) {
          var ex, stats;

          path = require('path').normalize("" + dir + "/" + file);
          stats = fs.lstatSync(path);
          if (file.substr(0, 1) !== '.') {
            if (stats.isDirectory()) {
              return xsp.autoload(path, scope);
            } else {
              if (scope) {
                return xsp.require(path, dir);
              } else {
                try {
                  return require(path);
                } catch (_error) {
                  ex = _error;
                  trace.red("[xsp] autoload failed on: " + dir);
                  return console.error(ex);
                }
              }
            }
          }
        });
      } else {
        path = dir;
        if (scope) {
          return xsp.require(path, path.dirname(path));
        } else {
          try {
            return require(module);
          } catch (_error) {
            ex = _error;
            trace.red("[xsp] autoload failed on: " + dir);
            return console.error(ex);
          }
        }
      }
    } else {
      if (fs.existsSync("" + dir + ".js")) {
        try {
          if (scope) {
            return (_ref = require(dir)) != null ? _ref.call(xsp) : void 0;
          } else {
            return require(dir);
          }
        } catch (_error) {
          ex = _error;
          trace.red("[xsp] autoload failed on: " + dir);
          return inspect.red(ex);
        }
      } else {
        return trace.red("[xsp] autoload path not found: " + dir);
      }
    }
  };

  xsp.autoload("" + __dirname + "/prototype");

  app = xsp.app = express();

  locals = xsp.locals = {};

  inits = [];

  dictionaries = {};

  controllers = {};

  pathsTo = {};

  socketController = null;

  socketClient = null;

  xsp.configure = function(env, fce) {
    if (typeof env === 'string') {
      if (env === app.settings.env) {
        return app.configure(env, function() {
          return fce(app);
        });
      }
    } else {
      return app.configure(function() {
        return env(app);
      });
    }
  };

  xsp.init = function(env, fce) {
    if (typeof env === 'string') {
      if (env === app.settings.env) {
        return inits.push(fce.bind(xsp));
      }
    } else {
      return inits.push(env.bind(xsp));
    }
  };

  xsp.get = function() {
    var arg, controller, index, re, route, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;

    path = arguments[0];
    for (index = _i = 0, _len = arguments.length; _i < _len; index = ++_i) {
      arg = arguments[index];
      if (index > 0) {
        if (typeof arg === 'string') {
          arguments[index] = (_ref = controllers[arg]) != null ? _ref : arg;
        }
      }
    }
    controller = arguments[arguments.length - 1];
    for (index = _j = 0, _len1 = arguments.length; _j < _len1; index = ++_j) {
      arg = arguments[index];
      if (index > 0) {
        if (arg instanceof Function) {
          arguments[index] = arg.bind(xsp);
        } else {
          throw new Error('Undefined controller found in xsp.get(): ' + arg);
        }
      }
    }
    pathsTo[controller.__shortcut] = path;
    Array.prototype.splice.call(arguments, 1, 0, routed);
    re = app.get.apply(app, arguments);
    _ref1 = app.routes.get;
    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
      route = _ref1[_k];
      if (route.path === path) {
        route.controller = controller.__shortcut;
        if (path === '/:lang') {
          route.regexp = new RegExp("^\\/(?:(" + (xsp.cfg.locales.join('|')) + "))\\/?$", "i");
        }
      }
    }
    return re;
  };

  xsp.post = function() {
    var arg, controller, index, re, route, _i, _j, _k, _len, _len1, _len2, _ref;

    path = arguments[0];
    for (index = _i = 0, _len = arguments.length; _i < _len; index = ++_i) {
      arg = arguments[index];
      if (index > 0) {
        if (typeof arg === 'string') {
          arguments[index] = controllers[arg];
        }
      }
    }
    controller = arguments[arguments.length - 1];
    for (index = _j = 0, _len1 = arguments.length; _j < _len1; index = ++_j) {
      arg = arguments[index];
      if (index > 0) {
        if (arg instanceof Function) {
          arguments[index] = arg.bind(xsp);
        } else {
          throw new Error('Undefined controller found in xsp.post()');
        }
      }
    }
    pathsTo[controller.__shortcut] = path;
    Array.prototype.splice.call(arguments, 1, 0, routed);
    re = app.post.apply(app, arguments);
    _ref = app.routes.post;
    for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
      route = _ref[_k];
      if (route.path === path) {
        route.controller = controller.__shortcut;
      }
    }
    return re;
  };

  xsp.all = function() {
    var arg, controller, index, re, route, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;

    path = arguments[0];
    for (index = _i = 0, _len = arguments.length; _i < _len; index = ++_i) {
      arg = arguments[index];
      if (index > 0) {
        if (typeof arg === 'string') {
          arguments[index] = controllers[arg];
        }
      }
    }
    controller = arguments[arguments.length - 1];
    for (index = _j = 0, _len1 = arguments.length; _j < _len1; index = ++_j) {
      arg = arguments[index];
      if (index > 0) {
        if (arg instanceof Function) {
          arguments[index] = arg.bind(xsp);
        } else {
          throw new Error('Undefined controller found in xsp.all()');
        }
      }
    }
    pathsTo[controller.__shortcut] = path;
    Array.prototype.splice.call(arguments, 1, 0, routed);
    re = app.all.apply(app, arguments);
    _ref = app.routes.get;
    for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
      route = _ref[_k];
      if (route.path === path) {
        route.controller = controller.__shortcut;
      }
    }
    _ref1 = app.routes.post;
    for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
      route = _ref1[_l];
      if (route.path === path) {
        route.controller = controller.__shortcut;
      }
    }
    return re;
  };

  xsp.listen = function() {
    var dict, ex, init, locale, _i, _j, _len, _len1, _ref;

    xsp.autoload("" + __dirname + "/../../../app/config/routes", true);
    _ref = xsp.cfg.locales;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      locale = _ref[_i];
      try {
        dict = require("" + __dirname + "/../../../app/locales/" + locale + ".yml");
        dictionaries[locale] = dict[locale];
      } catch (_error) {
        ex = _error;
        trace.red("[xsp] failed to load localization " + locale + ".yml");
        inspect.red(ex);
      }
    }
    for (_j = 0, _len1 = inits.length; _j < _len1; _j++) {
      init = inits[_j];
      init.bind(xsp);
    }
    return async.series(inits, function(err) {
      var bapp, server,
        _this = this;

      app.set('hostname', xsp.cfg.hostname);
      bapp = express();
      bapp.use(express.vhost(xsp.cfg.host, app));
      bapp.use(function(req, res, next) {
        return res.redirect("http://" + xsp.cfg.hostname);
      });
      server = http.createServer(bapp);
      server.listen(xsp.cfg.port, function() {
        if (xsp.env !== 'test') {
          return trace.grey("[xsp] http server listening on " + xsp.cfg.hostname + " in " + app.settings.env + " mode");
        }
      });
      if (socketController) {
        socketController = new socketController(require('socket.io').listen(server));
      }
      if (xsp.cfg.ssl) {
        app.set('sslhostname', xsp.cfg.ssl.hostname);
        return async.parallel([
          function(callback) {
            return fs.readFile("" + __dirname + "/../../../ssl/" + xsp.cfg.ssl.privatekey, callback);
          }, function(callback) {
            return fs.readFile("" + __dirname + "/../../../ssl/" + xsp.cfg.ssl.certificate, callback);
          }
        ], function(err, results) {
          if (!err) {
            bapp = express();
            bapp.use(express.vhost(xsp.cfg.ssl.hostname, app));
            bapp.use(function(req, res, next) {
              return res.redirect("https://" + xsp.cfg.host);
            });
            return https.createServer({
              key: results[0].toString(),
              cert: results[1].toString()
            }, bapp).listen(xsp.cfg.ssl.port, function() {
              if (xsp.env !== 'test') {
                return trace.grey("[xsp] https server listening on " + xsp.cfg.ssl.hostname + " in " + app.settings.env + " mode");
              }
            });
          } else {
            return inspect.red(err);
          }
        });
      }
    });
  };

  xsp.translate = function(dictionary, path, variables) {
    var ex;

    if (typeof dictionary === 'string') {
      dictionary = dictionaries[dictionary];
    }
    if (!dictionary) {
      return "## " + path;
    }
    try {
      eval("var verb = dictionary." + path);
      if (verb === void 0 || verb === null) {
        return "## " + path;
      }
      if (variables) {
        return verb.format(variables);
      } else {
        return verb;
      }
    } catch (_error) {
      ex = _error;
      return "## " + path;
    }
  };

  xsp.dictionary = function(dictionary) {
    if (typeof dictionary === 'string') {
      dictionary = dictionaries[dictionary];
    }
    return dictionary;
  };

  xsp.saveDictionary = function(dictionary, callback) {
    var yml;

    if (typeof dictionary === 'string') {
      dictionary = dictionaries[dictionary];
    }
    yml = {};
    yml[dictionary._code] = dictionary;
    return fs.writeFile("" + __dirname + "/../../../app/locales/" + dictionary._code + ".yml", yaml.dump(yml), callback);
  };

  xsp.path = function(controller, lang) {
    var anchor, args, index, last;

    args = arguments;
    last = arguments[arguments.length - 1];
    anchor = '';
    if (typeof last === 'string' && last.substr(0, 1) === '#') {
      Array.prototype.pop.call(arguments);
      anchor = last;
    }
    if (typeof controller === 'function') {
      controller = controller.__shortcut;
    }
    path = pathsTo[controller];
    if (!path) {
      return '/';
    }
    if (path.substr(0, 6) !== '/:lang') {
      Array.prototype.splice.call(arguments, 1, 1);
    }
    index = 1;
    if (arguments.length > 1) {
      path = path.replace(/:[^\/]*/g, function(f) {
        var _ref;

        return (_ref = args[index++]) != null ? _ref : f;
      });
    }
    return path + anchor;
  };

  app.use(function(req, res, next) {
    var end, startTime;

    startTime = new Date;
    end = res.end;
    res.end = function(chunk, encoding) {
      var color;

      res.end = end;
      res.end(chunk, encoding);
      color = xsp.colors.green;
      if (res.statusCode >= 500) {
        color = xsp.colors.red;
      } else if (res.statusCode >= 400) {
        color = xsp.colors.yellow;
      } else if (res.statusCode >= 300) {
        color = xsp.colors.cyan;
      }
      if (xsp.env === 'development') {
        return trace.grey("[xsp] " + xsp.colors.grey + req.method + " " + req.originalUrl + " " + color + res.statusCode + xsp.colors.grey + " " + (new Date - startTime) + "ms" + xsp.colors.def);
      }
    };
    return next();
  });

  routed = function(req, res, next) {
    var l, n, render, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;

    req.defaults = xsp.languageDefaults(req);
    req.language = (_ref = (_ref1 = (_ref2 = (_ref3 = req.params) != null ? _ref3.lang : void 0) != null ? _ref2 : (_ref4 = req.cookies) != null ? _ref4.language : void 0) != null ? _ref1 : (_ref5 = req.defaults) != null ? _ref5.locale : void 0) != null ? _ref : xsp.cfg.default_locale;
    if (req.route.path.substr(0, 6) === '/:lang') {
      if (xsp.cfg.locales.indexOf(req.language) === -1) {
        res.redirect(xsp.path('app#index', (_ref6 = (_ref7 = req.defaults) != null ? _ref7.locale : void 0) != null ? _ref6 : xsp.cfg.default_locale));
        return;
      }
    }
    req.t = function(path, variables) {
      return xsp.translate(req.language, path, variables);
    };
    res.p = function(controller) {
      Array.prototype.splice.call(arguments, 1, 0, req.language);
      return xsp.path.apply(xsp, arguments);
    };
    res.locals.xsp = xsp;
    res.locals.req = req;
    res.locals.res = res;
    res.locals.t = res.locals.translate = req.t;
    res.locals.p = res.locals.path = res.p;
    res.locals.title = xsp.translate(req.language, 'app.name');
    res.locals.languages = xsp.cfg.locales;
    res.locals.menu = req.route.controller;
    for (n in locals) {
      l = locals[n];
      res.locals[n] = l;
    }
    render = res.render;
    res.render = function(view, variables, callback) {
      var title;

      res.render = render;
      if (typeof view === 'function') {
        view = void 0;
        variables = void 0;
        callback = view;
      }
      if (typeof view === 'object') {
        callback = variables;
        variables = view;
        view = void 0;
      }
      if (!view) {
        view = req.route.controller.replace(/#/g, '/');
      }
      res.locals.view = view;
      title = req.t("" + (view.replace(/\//g, '.')) + ".title");
      if (title.substr(0, 2) !== '##') {
        res.locals.title = title;
      }
      return res.render(view, variables, callback);
    };
    return next();
  };

  xsp.Controller = (function() {
    function Controller() {}

    return Controller;

  })();

  xsp.Model = (function() {
    function Model() {}

    return Model;

  })();

  xsp.ProtocolController = (function(_super) {
    __extends(ProtocolController, _super);

    function ProtocolController() {
      _ref = ProtocolController.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    ProtocolController.https = function(req, res, next) {
      if (req.protocol === 'https') {
        return next();
      } else {
        return res.send(403.4, "Forbidden");
      }
    };

    ProtocolController.http = function(req, res, next) {
      if (req.protocol === 'http') {
        return next();
      } else {
        return res.send(403, "Forbidden");
      }
    };

    return ProtocolController;

  })(xsp.Controller);

  xsp.SocketsClient = (function() {
    SocketsClient.prototype.socket = null;

    SocketsClient.prototype.controller = null;

    SocketsClient.prototype.ip = null;

    function SocketsClient(socket) {
      var _ref1,
        _this = this;

      this.socket = socket;
      this.ip = (_ref1 = socket.handshake.headers['x-forwarded-for']) != null ? _ref1 : socket.handshake.address.address;
      this.socket.on('disconnect', function() {
        socketController.clients.splice(socketController.clients.indexOf(_this), 1);
        return socketController.disconnected(_this);
      });
    }

    return SocketsClient;

  })();

  xsp.SocketsController = (function() {
    SocketsController.prototype.io = null;

    SocketsController.prototype.clients = null;

    function SocketsController(io) {
      var _this = this;

      this.io = io;
      this.clients = [];
      this.io.sockets.on('connection', function(socket) {
        var client;

        client = new socketClient(socket);
        _this.clients.push(client);
        return _this.connected(client);
      });
    }

    SocketsController.prototype.connected = function(client) {};

    SocketsController.prototype.disconnected = function(client) {};

    return SocketsController;

  })();

  xsp.basicAuth = require('./middleware/basicAuth');

  xsp.autoload("" + __dirname + "/../../../app/helpers", true);

  xsp.autoload("" + __dirname + "/../../../app/models", true);

  xsp.autoload("" + __dirname + "/../../../app/controllers", true);

  for (name in xsp) {
    model = xsp[name];
    if ((model != null ? model.prototype : void 0) instanceof xsp.Model) {
      _ref1 = model.schema;
      for (key in _ref1) {
        value = _ref1[key];
        if (typeof value === 'string') {
          if (value.substr(0, 1) === '@') {
            model.schema[key] = xsp[value.substr(1)];
          } else {
            model.schema[key] = global[value];
          }
        }
      }
    }
  }

  for (name in xsp) {
    controller = xsp[name];
    if (!((controller != null ? controller.prototype : void 0) instanceof xsp.Controller)) {
      continue;
    }
    name = name.toLowerCase();
    if (name.substr(name.length - 10) === 'controller') {
      name = name.substr(0, name.length - 10);
    }
    for (route in controller) {
      fce = controller[route];
      if (!(route.substr(0, 2) !== '__')) {
        continue;
      }
      controllers["" + name + "#" + route] = fce;
      fce.__shortcut = "" + name + "#" + route;
    }
  }

  for (name in xsp) {
    controller = xsp[name];
    if ((controller != null ? controller.prototype : void 0) instanceof xsp.SocketsController) {
      socketController = controller;
    }
  }

  for (name in xsp) {
    client = xsp[name];
    if ((client != null ? client.prototype : void 0) instanceof xsp.SocketsClient) {
      socketClient = client;
    }
  }

}).call(this);
